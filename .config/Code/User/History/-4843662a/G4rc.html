    ~   <!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=<device-width>, initial-scale=1.0">
    <title>Software Process Model</title>
</head>

<body>
    <h3>Software Project Concept</h3>
    <p>A set of program written to perform a particular task is called software. It is the interface between the
        computer and the user.</p>
    <p>A project is a well-defined task, which is a collection of several operations done to achieve a goal.
    </p>

    <p>A software project is the complete procedure of software development from requirement analysis to testing and
        maintenance, carried out according to the execution methodologies, in a specified period to achieve the
        desired goal.</p>

    <h3>Concept of Software Development process</h3>
    <p>The software development process defines a sequence of tasks that must be carried out to build new software. It
        groups the development activities into a sequence of phases. A phase in sequence can only commence on the
        previous phase has been completed. A report is produced at the end of each phase, describing what has been
        achieved and outlining the plan for the next phase.<br />
        Features of Software Development Process
    <ul>
        <li>Optimizes business process</li>
        <li>Helps save cost</li>
        <li>Offers competitive advantage</li>
        <li>Custom software is highly adaptable</li>
    </ul>
    </p>

    <h3>Concept of SDLC Life Cycle</h3>
    <p>All of the software development goes through a number of phases which start from the early stage of requirement
        determination to final step of system maintenance after it has gone into use is called the software development life
        cycle. SDLC facilitates standardization and management control of the development process decreasing
        individuals' independence and carefulness in design decisions.<br /> The following are the basic phases of SDLC:
    </p>
    <ol>
        <li>Planning (Investigation)</li>
        <p>This is the first step of SDLC. This phase begins when the need is identified for a new or modified
            software/system. During this phase, the system analyst thoroughly studies the organization's current
            procedure and the software used to perform organizational tasks. </p>
        <li>System Analysis</li>
        <p>System analysis is an important activity that takes place when the new information system is being changed.
            It follows the feasibility study and involves a detailed study of the current system, leading to
            specifications of a new system. <br /> During system analysis, data are collected from various available
            sources by using tools such as interviews, on-site observation, questionnaires, sampling, research, and
            documentation. All procedures, requirements must be analyzed and documented. Finally, system analysis
            determines the shape, form, strength, capability, and even the life of the system. </p>

        <li>System Design</li>
        <p>This is the most creative and challenging phase of SDLC. It is concerned with the design of the final system.
            During this phase, the designer must design all the aspects of the system from the input and output screen
            to reports, databases, and processes of computing. <br /> Many system design tools are available to help
            teams through the steps of system design, some of them are algorithm, flowchart, DFD (Data Flow Diagram), ER
            diagram (Entity-Relationship), etc. </p>

        <li>System Development</li>
        <p>During the development phase, the developers play a key role, in creating or customizing the system. In this
            phase technical writers also work with the developers to develop the technical documents for the system. The
            technical document explains how and why a certain procedure is coded in specific ways. The
            major goal of this phase is to translate the problem studied in the system analysis and design phase into
            the proper physical system.</p>

        <li>System Testing</li>
        <p>After the development of the whole components of the system, a test plan must be conducted and all the
            testing must be done accordingly to that schedule. A test schedule may contain the following steps:<br />
        <ol>
            <li>Test unit specification</li>
            <li>Features to be tested</li>
            <li>The approach used for testing</li>
            <li>Test deliverables</li>
            <li>Schedule</li>
            <li>Personnel allocation</li>
        </ol><br /> This phase is the costliest, most time-consuming, and most complex.
        </p>
    </ol>

    <h3>System Implementation</h3>
    <p>System implementation is the way of carrying out a developed system into working condition. It involves testing,
        debugging, loading, or distributing the developed system to user sites and training using personnel. <br /> It
        is the stage of a system to the new system to perform work. The process of moving from the old system to the new
        system is called System Conversion. There are different ways of system conversion:
        <br />
    <ol>
        <li>Direct conversion</li>
        <li>Parallel conversion </li>
        <li>Phased conversion</li>
        <li>Pilot conversion</li>
    </ol>
    </p>

    <h3>System Maintenance and Feedback</h3>
    <p>Correcting and upgrading process of the system is called system maintenance. Maintenance is necessary to
        eliminate errors in the working system. Proper testing and documentation should significantly reduce the
        frequency and extent of the required maintenance. System maintenance involves training sessions, documentation
        of the system, and support after the sale. <br /> In this phase, the system developer makes the required changes
        according to the specification. </p>


    <h3>System Review</h3>
    <p>This phase is carried out by a group consisting of a representative from the client departments, internal audits,
        system analysts, and data processing. Its basic purpose is to see if the system has met the objectives set for it
        or not. </p>


    <h3>System Analyst Vs System Engineer</h3>
    <h3>System Analyst</h3>
    <p>A system analyst is a senior-most person in the system development hierarchy, who analyses the system and takes
        the responsibility for the development of computer based new information system for the end-users. <br />
    <h4>Roles and Responsibilities of System Analyst</h4>
    <ul>
        <li>Investigator and Monitor</li>
        <p>A system analyst should investigate the existing system to find the reasons for its failure. It involves
            understanding users' requirements by interviewing users, finding out what information is being used in
            the current system and what is users' expectations.</p>

        <li>Prioritizing Requirements by Consensus</li>
        <p>In every organization there are many users and all users may have different information. It may not be
            possible to satisfy every user's need due to limited computing capabilities, programmers, etc. So, system analysts must set priorities by having a common meeting with all the users and arriving at a
            consensus. </p>

        <li>Gathering data, facts, and opinions of users</li>
        <p>Having determined the information needs and their priorities, the system analyst must develop the system
            with the active and willing cooperation of all users.</p>

        <li>Architect</li>
        <p>The system analyst's role as an architect is an interface between the user's logical requirements and the
            detailed physical system design. A system analyst must study the problem in-depth and suggest an alternative
            solution to the management. </p>

        <li>Drawing up specifications</li>
        <p>A key job of a system analyst is to obtain the functional specifications of the system to be designed in a form
            that can be understood by users.</p>

        <li>Evaluating System</li>
        <p>Analyst evaluates the system after it has been in use for a reasonable period of time. For this, an
            analyst must have an open mind to accept valid criticism. </p>
    </ul>
    </p>

    <h3>System Engineers</h3>
    <p>System engineers apply principles and techniques of engineering, mathematics, and computer science to the design,
        development, and testing of software applications for computers. There are many types of software that a
        software engineer can develop, such as an operating system, computer games, middleware, business applications, etc.
    </p>
    <p>Responsibilities of Software Engineer</p>
    <ul>
        <li>Developing and directing software system validation and testing methods.</li>
        <li>Directing our software programming initiatives.</li>
        <li>Overseeing the development of documentation.</li>
        <li>Working closely with clients and cross-functional departments to communicate project statuses and proposals.
        </li>
        <li>Managing the software development lifecycle.</li>
        <li>Testing new software and fixing bugs</li>
        <li>Shaping the future of the system</li>
    </ul>

    <h3>Requirement Collection Methods</h3>
    <p>Requirements and problems of all users, to be solved by the computerized system are studied. The system analyst and
        end-users sit together, discuss their problems, and determine the requirements to be met by the system being
        contemplated.</p>
    <ol>
        <li>Survey/Questionnaire</li>
        <li>Feasibility analysis</li>
        <li>Interview</li>
        <li>On-site Observation</li>
        <li>Brainstorming</li>
        <li>Document Analysis</li>
        <li>Focus Group</li>
        <li>Prototyping</li>
    </ol>

    <h3>Concept of System Design</h3>
    <p>This is the most creative and challenging part of SDLC. In this phase, the designer tackles the problem that how
        to develop the selected solution. The analyst and designer involved in the development of the system often use
        combination of top-down and bottom-up design approach. To create the logical design different kinds of tools are
        used: </p>
    <ul>
        <li>Algorithm</li>
        <p>A designer uses the modeling languages to express information and knowledge in a structure of a system that is
            defined by a consistent set of rules and definitions.</p>

        <li>Flowchart</li>
        <p>System flowcharts are a way of displaying how data flows in a system and how decisions are made to control
            events.</p>

        <li>Pseudo codes</li>
        <p>Software developers write pseudo code to ensure that programmers can understand a software project's code
            accordingly. Simple English language and syntaxes are used to write codes. </p>

        <li>Decision table</li>
        <p>The decision table (cause-effect table) is a software testing technique that is used for testing the system
            behavior for different combinations which is a systematic approach where the different input combinations
            and their corresponding system behavior are captured in a tabular form.</p>

        <li>Data flow diagram</li>
        <p>A Data Flow Diagram (DFD) is a traditional visual representation of the information flows within a system.
            DFD can be manual, automated, or a combination of both. The objective of a DFD is to show the scope and
            boundaries of a system as a whole.</p>

        <li>E-R diagram</li>
        <p>Enitity Relationship Diagram is a diagram that displays the relationship of entity sets stored in a
            database. ER diagrams help to explain the logical structure of databases which are created based on three
            basic components: entities, attributes, and relationships.</p>
    </ul>

    <h3>Software and Quality</h3>
    <p> Software quality is defined as a field of study and practice that describes the desirable attributes of software
        products. There are two main approaches to software quality: defect management and quality attributes</p>

    <h3>Defect Management</h3>
    <p>It can be regarded as any failure to address end-user requirements. Common defects include missed or
        misunderstood requirements and errors in design, functional logic, data relationships, processing time, validity
        checking, and coding errors. More mature software development organizations use tools, such as defect matrices
        (for counting the number of defects that pass through development phases) and control charts, to measure and
        improve development process capability</p>

    <h3>Quality Attributes</h3>
    <p>This approach to software quality is best exemplified by fixed quality models, such as ISO/IEC 25010:2011. This
        standard describes a hierarchy of eight quality characteristics, each composed of sub-characteristics:</p>
    <ul>
        <li>Functional suitability</li>
        <li>Reliability</li>
        <li>Operability</li>
        <li>Performance efficiency</li>
        <li>Security</li>
        <li>Compatibility</li>
        <li>Maintainability</li>
        <li>Transferability</li>

    </ul>

    <p>Some quality of software quality are:</p>
    <ul>
        <li>Accuracy</li>
        <li>Availability</li>
        <li>Compatibility</li>
        <li>Functionality</li>
        <li>Manageability</li>
        <li>Performance</li>
        <li>Usability</li>
    </ul>

    <h3>Software Development Model</h3>
    <p>Software Development Life Cycle is a systematic process of developing any software system. It is a part of software engineering. The manage the level of complexity, a number of SDLC models have been developed.  </p>

    <ol>
        <li>Waterfall Model</li>
        <p>It is the simplest software development life cycle model, which states that the phases are organized in a linear order. In this model, the result of each phase is one or more documents that are approved and the following phase should not start until the previous phase has finished these stages and fed information to each other. This model is the parent of the incremental model and is not used nowadays.</p>

        <p>Advantages</p>
        <ul>
            <li>Allows for departmentalization and managerial control</li>
            <li>Each phase of development proceeds in strict order, without any overlapping or iterative steps.</li>
        </ul>
        <p>Disadvantages</p>
        <ul>
            <li>It does not allow for much reflection or revision</li>
            <li>Once an application is in the testing phase, it is very difficult to go back and change something.</li>
        </ul>

        <li>Prototyping Model</li>
        <p>This model begins with requirement gathering. Developer and customer meet and define the overall objectives of the software, identify whatever requirements are known, and identify the areas which require further definition. In many instances, the user only has a general view of what is expected from the software product. <br/> This type of model is employed when it is very difficult to obtain exact requirements from the customer. While making the model, the user keeps giving feedbacks from time to time, and based on it, a prototype is made. A completely build sample model is shown to the user and based on his feedback; the SRS (System Requirements Specifications) document is prepared.</p>

        <p>Advantages</p>
        <ul>
            <li>When a prototype is shown to the user, he/she gets a proper clarity and 'feel' of the functionality of the software and he can suggest changes and modifications.</li>
            <li>Feedback from the customer is received periodically and the changes do not come as a last-minute surprise.</li>
            <li>Errors can be detected much earlier as the system is made side by side.</li>
        </ul>
        <p>Disadvantages</p>
        <ul>
            <li>Prototyping is usually at the cost of the developer. So, it should be done using minimal resources.</li>
            <li>Once we get proper requirements from the client after showing the prototype model, it may be of no use. That is why; sometimes we refer to the prototype model, it may be of no use. This is why; sometimes we refer to the prototype as a "Throw-away" prototype.</li>
        </ul>

        <h3>Agile Model</h3>
        <p>This model is one of the simplest and most effective processes to turn a vision for a business need into software solutions. Agile is a term used to describe software development approaches that employ continual planning, learning, improvement, team collaboration, evolutionary development, and early delivery. After developing this model software developers can make easy and rapid project achievements. <br/> There are six stages in the agile development approach</p>
        <ul>
            <li>Planning</li>
            <li>Requirements Analysis</li>
            <li>Design</li>
            <li>Development</li>
            <li>Unit Testing</li>
            <li>Deployment</li>
        </ul>

        <p>Advantages</p>
        <ul>
            <li>The customers are satisfied because after every step working feature of the software is delivered to them.</li>
            <li>Customers can have a look of the working feature which fulfilled their expectations.</li>
            <li>The daily interactions are required between the consumer and the developers</li>
        </ul>

        <p>Disadvantages</p>
        <ul>
            <li>The documentation is less</li>
            <li>Because of the ever-evolving features, there is always a risk of the ever-lasting project</li>
        </ul>

    </ol>

</body>

</html>